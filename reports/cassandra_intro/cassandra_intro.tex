\documentclass[9pt,twocolumn,twoside]{idsi}
% Defines a new command for the horizontal lines, change thickness here
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} 
\usepackage{listings}
\renewcommand{\headrulewidth}{2pt}
\fancypagestyle{plain}{%
  \fancyhead[L]{
    \begin{tabular}{ll}
%        \includegraphics[scale=0.15]{figs/ncsa_vertical} 
    \end{tabular}
  }
  \fancyhead[C]{
      	\begin{tabular}[m]{c}
		  	\fontsize{20}{20} Illinois Data Science Initiative    	
		\end{tabular}
  }

  \fancyhead[R]{
    \begin{tabular}{ll}
%	  	\includegraphics[scale=0.125]{figs/ill}  		
  	\end{tabular}
  }
  
  \fancyfoot[C]{\thepage}
}
\pagestyle{plain}
\def \report_title {Introduction to Cassandra}
\author[1]{Bhuvan Venkatesh}
\author[2]{Robert Brunner}
\affil[1]{National Center For Supercomputing Applications (NCSA)}
\affil[2]{Laboratory for Computation, Data, and Machine Learning}
\title{Introduction to Cassandra}

\begin{abstract}

\end{abstract}

\begin{document}

\coverpage{Introduction to Cassandra}{Bhuvan Venkatesh}

\maketitle

\section{Introduction}

Apache Cassandra is an Open Source distributed database. The characteristics of Cassandra is that it is a high availability and fault tolerant database. The use cases for Cassandra are when you are familiar with the typical SQL databases and you need a way of modeling

\section{Installation}

For those of you on docker to run all you need to do is

\begin{lstlisting}[breaklines]
$ docker pull cassandra
$ docker run cassandra
\end{lstlisting}

If not, the non-dockerized installation is below.

\subsection{Prerequisites}
\begin{enumerate}
  \item Java 1.6 or Above
  \item Python 2.7 or Above
\end{enumerate}

First you will need to set a new user for cassandra, letting cassandra run under normal users is not recommended, so we create a new user

\begin{lstlisting}[breaklines]
$ useradd cassandra # Name for the user
\end{lstlisting}

Navigate to $http://cassandra.apache.org/download/$ and select the most recent stable version of cassandra (Usually the most recent or the second most recent version) and execute

\begin{lstlisting}[breaklines]
$ wget <url>
$ tar zxvf <file>.tar.gz
$ mv <folder> /opt/cassandra # May need root
$ export CASSANDRA_HOME=/opt/cassandra
$ chown -R cassandra $CASSANDRA_HOME
\end{lstlisting}

After this, create the directories that cassandra keeps its data in.

\begin{lstlisting}[breaklines]
$ mkdir /var/lib/cassandra
$ chown cassandra /var/lib/cassandra
$ mkdir /var/log/cassandra
$ chown cassandra /var/log/cassandra
\end{lstlisting}

You can change this in the settings explained in a future section.

To run cassandra switch the cassandra user, and execute the cassandra executable

\begin{lstlisting}[breaklines]
$ sudo su cassandra
$ cd $CASSANDRA_HOME
$ ./bin/cassandra -f # or if you want to run it in the background -d
\end{lstlisting}

And you have cassandra running! To make sure that everything is working on a different terminal

\begin{lstlisting}[breaklines]
$ cd $CASSANDRA_HOME
$ ./bin/cqlsh
>       #If there are no errors, your single node cluster is up.
\end{lstlisting}

\section{Configuring multinode clusters}

\subsection{Backing up date on previous}

First, if you have a single node cluster you \textbf{must} complete these instructions or your system will be in a halfway state. Delete all the data associated with your cassandra instance. If you have important data, there are ways to back it up.

% Maybe put in a fabric script that can do this for you

\begin{lstlisting}
> ./bin/cqlsh
> COPY table_name TO '/user/you/file_name'
# After the switch to multinode you can do
> COPY table_name FROM '/user/you/file_name'
\end{lstlisting}

If you are comfortable with your data backup, delete the old datastore

\begin{lstlisting}[breaklines]
sudo rm -rf /var/lib/cassandra/*
\end{lstlisting}

\subsection{Setting up the configurations}

Got to the \$CASSANDRA\_HOME/cassandra.yaml file. You can update the following values to set up a multi node system

\begin{lstlisting}[breaklines]
# Find these values in the existing file
cluster_name: 'MustBeNamed'

# Some fields may be added
seed_provider:
  - class_name: org.apache.cassandra.locator.SimpleSeedProvider
    parameters:
         - seeds: "this_server_ip,server_ip_2,..."

# Firewall Addresses
rpc_address: this_server_ip
listen_address: this_server_ip

# Snitches
endpoint_snitch: GossipingPropertyFileSnitch

\end{lstlisting}

\begin{enumerate}
\item cluster\_name: The name of your cluster. In order for other nodes to join it must be named the \textbf{same thing} on each server.
\item seed\_provider: This property is how cassandra knows about which nodes are directly connected to which. It will assume that the nodes are connected in a ring where the first ip is connected to the second, the second to the third and so on and the last is connected to the first.
\item rpc\_address, listen\_address: These are the two IPs that cassandra will do its communication on. These are usually localhost and default to two ports.
\item endpoint\_snitch: A snitch in computing shares metadata about the cluster (the health of each node, the free space etc) by occasionally telling its neighbors (fingertable accessible). This is the gossip protocol in work and that is why we go with the GossipingPropertyFileSnitch and not the SimpleSnitch for fault tolerance.
\end{enumerate}

For those on linux systems iptables are the usualy firewall the kernel has up to block incoming traffic, we will need to circumvent that.

\begin{lstlisting}[breaklines]
# Redo the following command for each
# machine connected to a single machine.

$ iptable -A INPUT \ # We are going to be receiving data
  -p tcp -s connected_machine_ip \ # Replace the IP as goes
  -m multiport --dports 7000,9042 \ # Default port
  -m state --state NEW,ESTABLISHED -j ACCEPT
$ service iptables-persistent restart
\end{lstlisting}

To see if it worked try the following command.

\begin{lstlisting}[breaklines]
$ $CASSANDRA_HOME/bin/cqlsh ANY_SERVER 9042
\end{lstlisting}


\section{Overview of data modeling}

If you are familiar with more traditional Relational Database Management Systems (RDBMS) then you are familiar with the concept of tables and joins where the table represents spreadsheets. Imagine Cassandra as a traditional RDBMS without the ability to do JOINs and where every statement ought to have a LIMIT BY for performance (there are ways around it).

If you are otherwise not familiar with traditional data stores, cassandra stores its data in tables, much like a spreadsheet. The tables live in entities called keyspaces. Keyspaces are ways for cassandra to keep track of resillience levels in tables in cqlsh syntax here is how you create one.

\begin{lstlisting}

> CREATE KEYSPACE "KeySpace Name: WITH replication = 
      {
        'class': ‘Strategy name’, 
        'replication_factor' : 'Number of replications'
      };

\end{lstlisting}


\section{CQLSH/Drivers}

There are two usual ways of interacting with cassandra, either the cqlsh executable or drivers for a specific programming language.

The CQLSH command line is mainly for maintenance or executing queries during setup/backup/destruction. This is because it is easy to use, easy to script, and easy to check for errors. But, there are drawbacks to using it. One drawback is CQLSH will \textit{always} connect the instance that you supply it with. Cassandra thrives on the ability for any client to connect to any node, reducing the point of failures and helps load balance the users among the cluster which decreases the probability of failures.

This is where community drivers come in. One can find drivers for many popular programming languages. One such driver for python (the highly popular datastax cassandra-python) is showcased in the code snippet below.

\begin{lstlisting}[language=Python]
from cassandra.cluster import Cluster
from cassandra.policies import DCAwareRoundRobinPolicy

cluster = Cluster(
    ['machine_ip_1', ...],
    port=...,
    load_balancing_policy=DCAwareRoundRobinPolicy(local_dc='TIMEZONE'),
    )
try:
  sess = cluster.connect()
  sess.set_keyspace('...')
  rows = sess.execute('SELECT name FROM users \
              WHERE email=%s', ['email1@gmail.com'])
  for user_row in rows:
      print(user_row.name)
except:
  pass
finally:
  # No Need to close inherently!
\end{lstlisting}

\section{Tuning Params}


\section{Usual Do Nots}

Although cassandra gives you a lot of tunability parameters there are practices that should be avoided at all cost because it severly impacts the performance or the reliability of the database.

\begin{enumerate}
\item Do not put cassandra's data files on network attached storage
\item Try not to host cassandra's data files directly on hadoop either, cassandra has reliability built into it.
\end{enumerate}


\section*{References}




\end{document}